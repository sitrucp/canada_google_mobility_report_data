
<html>

<head>
  <title>Canadian Province Heatmap</title>
  <meta name="description" content="">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">

  <style>
    body {
      margin: 0px auto;
      max-width: 700px;
      font-family: "Open Sans", sans-serif;
    }

    .graphic {
      font-family: "Open Sans", sans-serif;
      color: #333;
      fill: #333;
    }


    .hed {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .dek {
      font-size: 16px;
      color: #555;
      margin-bottom: 15px;
    }

    .footnote {
      font-size: 14px;
      color: #555;
      margin-top: 10px;
    }

    .footnote a {
      color: #888;
      text-decoration: underline dashed;
    }

    .axis path{
      display: none;
    }

    .axis text,
    .divcolumn .title2 {
      fill: #4c4c4c;
      font-size: 12px;
    }

    .bar {
      fill: steelblue;
    }

    .column .bar--underlying {
      fill: #fff;
    }

    .label {
      font-size: 12px;
      fill: #4c4c4c;
    }

    .label--white {
      fill: #fff;
    }

    .title2 {

      -webkit-user-modify: read-write;
      -moz-user-modify: read-write;
      user-modify: read-write;
      overflow-wrap: break-word;
      -webkit-line-break: after-white-space;
      -moz-line-break: after-white-space;
    }

    .source {
      font-size: 16px;
      margin: 16px 0 8px 0;
      font-weight: 700;
      color:#323132;
    }

    g.tick text{
      font-size:12px;
      fill:#323132;
    }

    @media only screen and (max-width: 610px) {
      text,#keyunit{
        font-size:12px;
      }
    }

  </style>
</head>

<body>

  <div id="key"></div>
  <div id="charts"></div>
  <h6 class="source">Source: Office for National Statistics, Google Community Mobility Reports</h6>

  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://cdn.ons.gov.uk/vendor/pym/1.3.2/pym.min.js" type="text/javascript"></script>
  <script src="../ws_covid_canada_google_mobility/lib/simple-statistics.min.js"></script>
  <script src="../ws_covid_canada_google_mobility/lib/chroma.min.js"></script>
  <script src="../ws_covid_canada_google_mobility/lib/queue.js"></script>
  <script src="../ws_covid_canada_google_mobility/lib/modernizr.svg.min.js" type="text/javascript"></script>
  <script>
    var pymChild = null;
    var graphic_data = [];



    function drawGraphic() {
      var chartwidth = parseInt(d3.select("body").style("width"));
      legendformat = d3.format("." + dvc.essential.legenddecimals + "f");
      displayformat = d3.format("." + dvc.essential.displaydecimals + "f");


      chosenCountries = dvc.essential.chosenCountries;

      // replace d.Country with d.Prov (AB, BC, etc)

      just6 = graphic_data.filter(function(d) {
        return chosenCountries.contains(d.Prov);
      })

      //create custom sorting index as set by entry of countries in the config
      sortObject={}
      for(i=0;i<chosenCountries.length;i++){
        sortObject[chosenCountries[i]]=i;
      }

      categorySort={}
      for(i=0;i<dvc.essential.categorySort.length;i++){
        categorySort[dvc.essential.categorySort[i]]=i;
      }

      just6.sort(function(a,b){
        return categorySort[a.category] - categorySort[b.category]
      })
      just6.sort(function(a,b){
        return sortObject[a.Prov] - sortObject[b.Prov]
      })

      nameCodeLookup={}
      for(i=0;i<just6.length;i++){
        nameCodeLookup[just6[i].Prov]=just6[i].location
      }

      columnDates = Object.keys(graphic_data[0]).filter(function(d) {
        return /^[A-Z]/i.test(d) == false;
      });

      dates = columnDates.map(function(d) {
        return d3.timeParse(dvc.essential.timeParseFormat)(d);
      });


      nested = d3.nest()
        .key(function(d) {
          return d.Category
        })
        .key(function(d) {
          return d.Prov
        })
        .entries(just6)

      if (chartwidth < dvc.optional.mobileBreakpoint) {
        var screenSize = "small";
      } else {
        var screenSize = "medium"
      }

      var margin = dvc.optional.margin[screenSize]
      // get height of each category from on
      var categoryHeight = dvc.essential.categoryHeight[screenSize]
      // set total svg height as the num categories * category height
      var height = categoryHeight * chosenCountries.length
      var width = chartwidth - margin.left - margin.right;

      // data should be an array with an object where the key is the category name.
      // The value is an array of datapoints/objects with a date and magnitude.

      defineBreaks(just6);
      setupScales();
      createKey();

      var x = d3.scaleTime()
        .domain(d3.extent(dates))
        .range([0, width])

      var svg = d3.select('div#charts')
        .selectAll('svg')
        .data(nested)
        .enter()
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('class', "group")
        .attr('transform', function(d, i) {
          return 'translate(' + margin.left + ',' + margin.top + ')'
        });

      svg.append('text')
        .text(function(d) {
          return d.key
        })
        .attr('y', -margin.top + 12)
        .attr('x', -margin.left)
        .attr('font-weight', 700)
        .style("font-size", "12px")
        .style("fill", "#323132");

      category = svg.selectAll('g.category')
        .data(function(d) {
          return d.values;
        })
        .enter()
        .append('g')
        .attr('class', "category")
        .attr('transform', function(d, i) {
          return 'translate(0,' + (i * categoryHeight + margin.top) + ')'
        });

      category.append('text')
        .text(function(d) {
          return nameCodeLookup[d.key]
        })
        .attr("x", -5)
        .attr('text-anchor', "end")

      blocks = category.selectAll('rect')
        .data(function(d) {
          return d.values.map(function(d) {
            var blank = []
            for (i = 0; i < columnDates.length; i++) {
              blank.push({
                "date": columnDates[i],
                "value": d[columnDates[i]]
              })
            }
            return blank;
          })[0]
        })
        .enter()
        .append('rect')
        .attr("x", function(d, i) {
          return x(d3.timeParse(dvc.essential.timeParseFormat)(d.date));
        })
        .attr('y', -15)
        .attr('height', 0.9 * categoryHeight)
        .attr("width", function() {
          return 0.95 * x.range()[1] / columnDates.length
        })
        .attr("fill", function(d) {
          return color(+d.value)
        })
        .on("mouseover", function(d) {
          setAxisVal(d.value)
        })
        .on("mouseout", function(d) {
          hideaxisVal();
        })

      function hideaxisVal() {
        d3.select("#currLine")
          .style("opacity", 0);

        d3.select("#currVal").text("")
          .style("opacity", 0);
      }

      function setAxisVal(value) {
        d3.select("#currLine")
          .style("opacity", function() {
            return 1;
          })
          .transition()
          .duration(400)
          .attr("x1", function() {
            return xkey(value);
          })
          .attr("x2", function() {

            return xkey(value);
          });


        d3.select("#currVal")
          .text(function() {
            return displayformat(value);
          })
          .style("opacity", 1)
          .transition()
          .duration(400)
          .attr("x", function() {
            return xkey(value);
          })
      }

      var xaxis = d3.axisBottom(x)
        .tickSize(3)
        .ticks(dvc.essential.tickNumber[screenSize])
      // .ticks(d3.timeDay.every(dvc.optional.tickDayInterval));

      d3.selectAll('path.domain')
        .style('opacity', 0);

      svg.append('g').attr("class", "axis").call(xaxis).attr('transform', "translate(" + (0.475 * x.range()[1] / columnDates.length) + "," + (chosenCountries.length * categoryHeight + 3) + ")")

      // make a key



      function wrap(text, width) {
        text.each(function() {
          var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
          while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
          }
        });
      } //end wrap function


      function defineBreaks(data) {
        //Flatten data values and work out breaks

        //If jenks or equal then flatten data so we can work out what the breaks need to be

        // Work out how many timepoints we have in our dataset; number of rows - area name & code // Look at linechart templates to see how?

        // parse data into columns
        if (dvc.essential.breaks == "jenks" || dvc.essential.breaks == "equal") {
          var values = [];
          allvalues = [];

          for (var column in columnDates) {
            values[columnDates[column]] = data.map(function(d) {
              return +d[columnDates[column]];
            }).filter(function(d) {
              return !isNaN(d);
            }).sort(d3.ascending);
            allvalues = allvalues.concat(values[columnDates[column]]);
          }
          allvalues.sort(d3.ascending);
        }


        if (dvc.essential.breaks == "jenks") {
          breaks = [];
          ss.ckmeans(allvalues, (dvc.essential.numberBreaks)).map(function(cluster, i) {
            if (i < dvc.essential.numberBreaks - 1) {
              breaks.push(cluster[0]);
            } else {
              breaks.push(cluster[0]);
              //if the last cluster take the last max value
              breaks.push(cluster[cluster.length - 1]);
            }
          });
        } else if (dvc.essential.breaks == "equal") {
          breaks = ss.equalIntervalBreaks(allvalues, dvc.essential.numberBreaks);
        } else {
          breaks = dvc.essential.breaks[0];
        }

        //round breaks to specified decimal places
        breaks = breaks.map(function(each_element) {
          return Number(each_element.toFixed(dvc.essential.legenddecimals));
        });

        //work out halfway point (for no data position)
        midpoint = breaks[0] + ((breaks[dvc.essential.numberBreaks] - breaks[0]) / 2);

      }

      function setupScales() {
        //set up d3 color scales
        //Load colours
        if (typeof dvc.essential.varcolour === 'string') {
          // colour = colorbrewer[dvc.varcolour][dvc.numberBreaks];
          colour = chroma.scale(dvc.essential.varcolour).colors(dvc.essential.numberBreaks);

        } else {
          colour = dvc.essential.varcolour;
        }

        //set up d3 color scales
        color = d3.scaleThreshold()
          .domain(breaks.slice(1))
          .range(colour.reverse());

      }


      function createKey() {
        var color = d3.scaleThreshold()
          .domain(breaks)
          .range(colour);

        keyheight = 65;

        keywidth = d3.select("#key").node().getBoundingClientRect().width;

        svgkey = d3.select("#key")
          .append("svg")
          .attr("id", "key")
          .attr("width", keywidth)
          .attr("height", keyheight);


        xkey = d3.scaleLinear()
          .domain([breaks[0], breaks[dvc.essential.numberBreaks]]) /*range for data*/
          .range([0, keywidth - 30]); /*range for pixels*/

        y = d3.scaleLinear()
          .domain([breaks[0], breaks[dvc.essential.numberBreaks]]) /*range for data*/
          .range([0, keywidth - 30]); /*range for pixels*/

        var xAxis = d3.axisBottom(xkey)
          .tickSize(15)
          .tickValues(color.domain())
          .tickFormat(legendformat);

        var g2 = svgkey.append("g").attr("id", "horiz")
          .attr("transform", "translate(15,30)");


        keyhor = d3.select("#horiz");

        g2.selectAll("rect")
          .data(color.range().map(function(d, i) {

            return {
              x0: i ? xkey(color.domain()[i + 1]) : xkey.range()[0],
              x1: i < color.domain().length ? xkey(color.domain()[i + 1]) : xkey.range()[1],
              z: d
            };
          }))
          .enter().append("rect")
          .attr("class", "blocks")
          .attr("height", 8)
          .attr("x", function(d) {
            return d.x0;
          })
          .attr("width", function(d) {
            return d.x1 - d.x0;
          })
          .style("opacity", 0.8)
          .style("fill", function(d) {
            return d.z;
          });


        g2.append("line")
          .attr("id", "currLine")
          .attr("x1", xkey(10))
          .attr("x2", xkey(10))
          .attr("y1", -10)
          .attr("y2", 8)
          .attr("stroke-width", "2px")
          .attr("stroke", "#000")
          .attr("opacity", 0);

        g2.append("text")
          .attr("id", "currVal")
          .attr("x", xkey(10))
          .attr("y", -15)
          .attr("fill", "#000")
          .attr('font-size',12)
          .text("");



        keyhor.selectAll("rect")
          .data(color.range().map(function(d, i) {
            return {
              x0: i ? xkey(color.domain()[i]) : xkey.range()[0],
              x1: i < color.domain().length ? xkey(color.domain()[i + 1]) : xkey.range()[1],
              z: d
            };
          }))
          .attr("x", function(d) {
            return d.x0;
          })
          .attr("width", function(d) {
            return d.x1 - d.x0;
          })
          .style("fill", function(d) {
            return d.z;
          });

        keyhor.call(xAxis).append("text")
          .attr("id", "caption")
          .attr("x", -63)
          .attr("y", -20)
          .text("");

        keyhor.append("rect")
          .attr("id", "keybar")
          .attr("width", 8)
          .attr("height", 0)
          .attr("transform", "translate(15,0)")
          .style("fill", "#ccc")
          .attr("x", xkey(0));

        d3.select("#key")
          .append("p")
          .attr("id", "keyunit")
          .style("margin-top", "-6px")
          .style("margin-left", "10px")
          .text(dvc.essential.varunit);
      } //end createkey


    } // closes drawGraphic

    if (Modernizr.svg) {
      d3.json("config.json", function(error, config) {
        dvc = config;

        d3.csv(dvc.essential.graphic_data_url, function(error, data) {

          graphic_data = data;

          pymChild = new pym.Child({
            renderCallback: drawGraphic
          });
        }) // close d3.csv
      })
    } else {
      pymChild = new pym.Child();
      pymChild.sendHeight();
    };

    Array.prototype.contains = function(obj) {
      var i = this.length;
      while (i--) {
        if (this[i] === obj) {
          return true;
        }
      }
      return false;
    }
  </script>
</body>

</html>
